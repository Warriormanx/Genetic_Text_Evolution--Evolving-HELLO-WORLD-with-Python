{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f1b3aae8-e4c1-4ad7-a9ee-d33a7d41c61d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tkinter as tk\n",
    "from tkinter import ttk\n",
    "import random\n",
    "import string\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n",
    "\n",
    "# Constants\n",
    "TARGET = \"HELLO WORLD\"\n",
    "DEFAULT_POP_SIZE = 200\n",
    "DEFAULT_MUTATION_RATE = 0.01\n",
    "MAX_GENERATIONS = 1000\n",
    "\n",
    "class GeneticAlgorithm:\n",
    "    def __init__(self, target, pop_size, mutation_rate):\n",
    "        self.target = target\n",
    "        self.pop_size = pop_size\n",
    "        self.mutation_rate = mutation_rate\n",
    "        self.population = self.create_initial_population()\n",
    "        self.fitness_history = []\n",
    "    \n",
    "    def create_initial_population(self):\n",
    "        return [''.join(random.choices(string.ascii_uppercase + ' ', k=len(self.target))) for _ in range(self.pop_size)]\n",
    "    \n",
    "    def fitness(self, individual):\n",
    "        return sum(1 for a, b in zip(individual, self.target) if a == b)\n",
    "    \n",
    "    def select_parents(self):\n",
    "        weighted_population = [(self.fitness(individual), individual) for individual in self.population]\n",
    "        total_fitness = sum(weight for weight, _ in weighted_population)\n",
    "        return random.choices([ind for _, ind in weighted_population], weights=[weight for weight, _ in weighted_population], k=2)\n",
    "    \n",
    "    def crossover(self, parent1, parent2):\n",
    "        split_point = random.randint(0, len(self.target) - 1)\n",
    "        return parent1[:split_point] + parent2[split_point:]\n",
    "    \n",
    "    def mutate(self, individual):\n",
    "        return ''.join(ch if random.random() > self.mutation_rate else random.choice(string.ascii_uppercase + ' ') for ch in individual)\n",
    "    \n",
    "    def evolve_population(self):\n",
    "        new_population = []\n",
    "        for _ in range(self.pop_size):\n",
    "            parent1, parent2 = self.select_parents()\n",
    "            child = self.crossover(parent1, parent2)\n",
    "            new_population.append(self.mutate(child))\n",
    "        self.population = new_population\n",
    "        best_fitness = max(self.fitness(ind) for ind in self.population)\n",
    "        self.fitness_history.append(best_fitness)\n",
    "\n",
    "class GUI:\n",
    "    def __init__(self, root):\n",
    "        self.root = root\n",
    "        self.root.title(\"Genetic Algorithm - Evolving Strings\")\n",
    "        self.algorithm = GeneticAlgorithm(TARGET, DEFAULT_POP_SIZE, DEFAULT_MUTATION_RATE)\n",
    "        self.generation = 0\n",
    "        self.best_individual = tk.StringVar()\n",
    "        self.evolving = False\n",
    "        self.create_widgets()\n",
    "        self.update_gui()\n",
    "    \n",
    "    def create_widgets(self):\n",
    "        frame = tk.Frame(self.root)\n",
    "        frame.pack()\n",
    "        \n",
    "        self.label = tk.Label(frame, text=\"Best Individual:\")\n",
    "        self.label.pack()\n",
    "        \n",
    "        self.best_label = tk.Label(frame, textvariable=self.best_individual)\n",
    "        self.best_label.pack()\n",
    "        \n",
    "        self.pop_size_label = tk.Label(frame, text=\"Population Size:\")\n",
    "        self.pop_size_label.pack()\n",
    "        self.pop_size_slider = tk.Scale(frame, from_=10, to=500, orient=tk.HORIZONTAL)\n",
    "        self.pop_size_slider.set(DEFAULT_POP_SIZE)\n",
    "        self.pop_size_slider.pack()\n",
    "        \n",
    "        self.mutation_rate_label = tk.Label(frame, text=\"Mutation Rate:\")\n",
    "        self.mutation_rate_label.pack()\n",
    "        self.mutation_rate_slider = tk.Scale(frame, from_=0.001, to=0.1, resolution=0.001, orient=tk.HORIZONTAL)\n",
    "        self.mutation_rate_slider.set(DEFAULT_MUTATION_RATE)\n",
    "        self.mutation_rate_slider.pack()\n",
    "        \n",
    "        self.generations_label = tk.Label(frame, text=\"Generations:\")\n",
    "        self.generations_label.pack()\n",
    "        self.generations_slider = tk.Scale(frame, from_=1, to=MAX_GENERATIONS, orient=tk.HORIZONTAL)\n",
    "        self.generations_slider.set(100)\n",
    "        self.generations_slider.pack()\n",
    "        \n",
    "        self.evolve_button = tk.Button(frame, text=\"Evolve One Generation\", command=self.evolve_one_generation)\n",
    "        self.evolve_button.pack()\n",
    "        \n",
    "        self.start_button = tk.Button(frame, text=\"Start Evolution\", command=self.start_evolution)\n",
    "        self.start_button.pack()\n",
    "        \n",
    "        self.stop_button = tk.Button(frame, text=\"Stop Evolution\", command=self.stop_evolution)\n",
    "        self.stop_button.pack()\n",
    "        \n",
    "        self.reset_button = tk.Button(frame, text=\"Reset\", command=self.reset_algorithm)\n",
    "        self.reset_button.pack()\n",
    "        \n",
    "        self.figure = plt.Figure(figsize=(5, 4), dpi=100)\n",
    "        self.ax = self.figure.add_subplot(111)\n",
    "        self.canvas = FigureCanvasTkAgg(self.figure, master=frame)\n",
    "        self.canvas.get_tk_widget().pack()\n",
    "    \n",
    "    def update_gui(self):\n",
    "        best = max(self.algorithm.population, key=self.algorithm.fitness)\n",
    "        self.best_individual.set(f\"{best} (Gen: {self.generation}, Fitness: {self.algorithm.fitness(best)})\")\n",
    "        self.ax.clear()\n",
    "        self.ax.plot(self.algorithm.fitness_history)\n",
    "        self.ax.set_xlabel(\"Generation\")\n",
    "        self.ax.set_ylabel(\"Fitness\")\n",
    "        self.ax.set_title(\"Fitness Over Generations\")\n",
    "        self.canvas.draw()\n",
    "    \n",
    "    def evolve_one_generation(self):\n",
    "        self.algorithm.evolve_population()\n",
    "        self.generation += 1\n",
    "        self.update_gui()\n",
    "        if self.best_individual.get().startswith(TARGET):\n",
    "            self.stop_evolution()\n",
    "\n",
    "    def start_evolution(self):\n",
    "        self.evolving = True\n",
    "        self.evolve_continuously()\n",
    "    \n",
    "    def stop_evolution(self):\n",
    "        self.evolving = False\n",
    "    \n",
    "    def evolve_continuously(self):\n",
    "        if self.evolving and self.generation < MAX_GENERATIONS:\n",
    "            self.evolve_one_generation()\n",
    "            self.root.after(100, self.evolve_continuously)  # Adjust the delay as needed\n",
    "    \n",
    "    def reset_algorithm(self):\n",
    "        pop_size = self.pop_size_slider.get()\n",
    "        mutation_rate = self.mutation_rate_slider.get()\n",
    "        self.algorithm = GeneticAlgorithm(TARGET, pop_size, mutation_rate)\n",
    "        self.generation = 0\n",
    "        self.evolving = False\n",
    "        self.update_gui()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    root = tk.Tk()\n",
    "    gui = GUI(root)\n",
    "    root.mainloop()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "143582d1-95a9-4276-99f1-bf7bddf36e5d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
